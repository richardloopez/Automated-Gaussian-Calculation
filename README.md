# Automated-Gaussian-Calculations
-Some Scripts to automate time-consumming tasks in a high-configurable way

-Each script has an explanation its functions and how it works


**AutoGaussian**: Automated Gaussian Calculation Pipeline for Ground and Excited States in
Solu_on
AutoGaussian is a Python script designed to automate Gaussian calcula_ons for mul_ple
molecules, focusing on ground and excited states in solu_on. It streamlines the process of
running batch calcula_ons with customizable steps, making it ideal for computa_onal
chemistry research. This script is specifically designed for calcula_ons using the Polarizable
Con_nuum Model (PCM) to simulate solvent effects, but can be adapted for other SCRF
methods.
Key Features
1. Mul_-format Input Support: Processes .xyz, .com, and .chk files.
2. Customizable Calcula_on Steps: Users can define and order specific calcula_on steps.
3. Concurrent Processing: Allows simultaneous calcula_on of mul_ple molecules.
4. Solvent Environment Modeling: Implements SCRF (Self-Consistent Reac_on Field)
calcula_ons.
5. Flexible Configura_on: Easy adjustment of memory, processors, and Gaussian
commands.
Func_onality
• The script automa_cally processes all .xyz, .com, and .chk files in the input folder.
• It applies the same charge and mul_plicity to all molecules and executes the same
calcula_on steps for each.
• For the first step:
• If using a .chk file, the input MUST include "Geom=Check Guess=Read".
• For .com or .xyz files, these keywords MUST BE OMITTED in the first step.
• Subsequent steps always HAVE TO include "Geom=Check Guess=Read", since they
automa_cally u_lize the .chk file from the previous step.
• Users can limit the number of concurrent calcula_ons to avoid overloading queue
systems.
• Calcula_on steps and their order are fully customizable.
Theore_cal Background
• This script leverages the Polarizable Con_nuum Model (PCM) to simulate solvent
effects in molecular calcula_ons. PCM treats the solvent as a con_nuous dielectric
medium, allowing for the efficient modeling of solva_on effects on molecular
proper_es. For more informa_on on PCM, refer to the Gaussian documenta_on:
[h@ps://gaussian.com/scrf/](h@ps://gaussian.com/scrf/)
Configura_on
• Set memory alloca_on and number of processors.
• Define specific Gaussian commands for each calcula_on step.
• Select which steps to execute and in what order.
• Set the maximum number of concurrent molecule calcula_ons.
Process Overview
1. Reads input files from the specified folder.
2. Creates standardized .cmxyz files for Gaussian input.
3. Executes defined calcula_on steps for each molecule.
4. Monitors log files for comple_on or errors.
5. Manages concurrent processing of mul_ple molecules.
Requirements
• Python 3.x
• Gaussian 16 (g16 command accessible in system PATH) (also modifiable to g09)
Usage
1. Place input files (.xyz, .com, .chk) in the 'input' folder.
2. Adjust configura_on parameters in the script if needed.
3. Run the script: sbatch AutoGaussian.py
This script is ideal for researchers and computa_onal chemists working with mul_ple molecules
and requiring consistent, automated Gaussian calcula_ons for ground and excited states in
solu_on environments.







**Boltzmann_Population_Calculator**
Descrip	on
This Python script calculates the Boltzmann popula	on distribu	on for a set of molecular
conforma	ons based on their energies. It's specifically designed to work with the output from
the "Print_Informa	on_Gaussian.py" script, which should be available in the same repository.
Features
- Reads energy data from a user-specified text file
- Calculates rela	ve Boltzmann popula	ons based on molecular energies
- Displays results sorted by popula	on percentage
How it works
1. The script prompts the user to enter the name of the input file containing molecular
energies.
2. It reads the file, extrac	ng molecule names and their corresponding energies in Hartree.
3. Using the Boltzmann distribu	on formula, it calculates the rela	ve popula	on of each
molecular conforma	on at a specified temperature (default is 298.15 K or 25°C).
4. The results are displayed, showing each molecule's name, energy, and rela	ve popula	on
percentage, sorted from highest to lowest popula	on.
Input File Format
The input file should be a text file with each line containing:
molecule_name,energy_in_Hartree
For example:
i01_A.log,-2820.251500
i01_B.log,-2820.247356
...
This format is compa	ble with the output generated by the "Print_Informa	on_Gaussian.py"
script.
Usage
1. Ensure you have Python 3 installed on your system.
2. Run the script:
./Boltzmann_Popula	on_Calculator.py
3. When prompted, enter the name of your input file (e.g., "Search_results.txt").
4. The script will display the calculated Boltzmann popula	ons for each molecule.
Constants
- Gas constant (R): 0.008314 kJ/(mol·K)
- Default temperature (T): 298.15 K (25°C)
- Conversion factor: 1 Hartree = 2625.5 kJ/mol
Note
This script assumes that the molecular energies are in equilibrium and that there are no
significant interac	ons between molecules other than those reflected in their energies.
Dependencies
This script uses only Python standard libraries and does not require any addi	onal installa	ons.
















**Print_Information_Gaussian.py** is designed to search for specific text within log files across a
directory structure. Here's an explana_on of its func_onality:
1. The script defines a search_string func_on that searches for specified text in log files
within a given folder. It can search from either the beginning or end of the file, as
specified by the user.
2. User input is collected for:
• The depth degree of subfolders to search
• The text to search for in the log files
• Whether to search from the beginning or end of the files
3. The explore_directory func_on recursively explores the directory structure up to the
specified depth. This func_on implements the concept of "depth grade" as explained:
• Depth grade 0: Searches in the immediate subfolders (e.g., iXX/)
• Depth grade 1: Searches in the next level of subfolders (e.g., iXX/iXX_X/)
• Depth grade 2: Searches in the third level of subfolders (e.g.,
iXX/iXX_X/iXX_X_X/)
The depth grade determines how deep the script will traverse the folder structure before
searching for log files.
4. For each directory at the appropriate depth, the script calls the search_string func_on
to search the log files.
5. Results are collected and wri3en to a file named "Search_Results.txt" in the base
directory. For each log file, it records either the found value or a message indica_ng
that the search text was not found.
6. The script is designed to be flexible, allowing searches at various directory depths and
from either the beginning or end of log files.
7. It includes error handling for cases where no log files are found in a directory.
8. The code is well-documented with comments and docstrings, explaining the purpose
of each func_on and major code block.
9. The script also includes a cita_on request and author informa_on, encouraging users to
credit the original author when using or adap_ng the code.
This script is par_cularly useful for projects with complex directory structures, such as those
involving the Seminario method, where log files need to be analyzed at specific folder depths.
The "frequencies_analyzer.py" script is designed to analyze .log files generated by vibrational calculations (likely from Gaussian) and extract information about vibrational frequencies. Here's a summary of what the script does:
Script Description:
1.	Processes .log files in the current directory:
The script recursively searches for all .log files in the current working directory and its subdirectories.
2.	Searches for vibrational frequency information:
It scans each .log file for the section containing vibrational frequencies. Specifically, it looks for the line containing "Low frequencies" and, from there, extracts the frequencies listed under "Frequencies --".
3.	Checks for negative frequencies:
If any frequencies are negative, it flags them as potential issues, as negative frequencies often indicate an unstable geometry (i.e., an optimization problem).
4.	Stores the results in a CSV file:
The results are saved in a CSV file called frequency_results.csv. For each processed file, it records the filename, the frequencies found, and whether any of the frequencies are negative.











**multixyz_to_pdb.py**
Overview
This Python script, **XYZ to PDB Converter**, is designed to convert molecular geometries
from an `.xyz` file into `.pdb` format using a base `.pdb` file. It creates mul&ple `.pdb` files, each
corresponding to a geometry from the `.xyz` input. This tool is par&cularly useful for tasks such
as reparameteriza&ons in molecular dynamics simula&ons (e.g., for AMBER).
Features
- Reads an `.xyz` file containing mul&ple molecular geometries.
- Uses a base `.pdb` file to ensure consistent atom ordering and nomenclature.
- Outputs mul&ple `.pdb` files, each containing one geometry from the `.xyz` file.
- Handles mismatches between atom counts in the `.xyz` and `.pdb` files with error repor&ng.
Requirements
- Python 3.x
- A valid `.xyz` file containing molecular geometries.
- A base `.pdb` file with the same atom ordering as the `.xyz` file.
Usage
Run the script from the command line with the following syntax:
python mul&xyz_to_pdb.py input.xyz base.pdb output_prefix
Arguments:
1. `input.xyz`: Path to the input `.xyz` file containing molecular geometries.
2. `base.pdb`: Path to the base `.pdb` file.
3. `output_prefix`: Prefix for the output `.pdb` files.
Example:
python mul&xyz_to_pdb.py molecule_geometries.xyz template.pdb output_molecule
This will generate files like `output_molecule_1.pdb`, `output_molecule_2.pdb`, etc., for each
geometry in `molecule_geometries.xyz`.
Input Files
   1. XYZ File:
- Contains mul&ple molecular geometries in XYZ format.
- Each geometry starts with the number of atoms, followed by a comment line, and then
atomic coordinates.
  2. Base PDB File:
- A valid PDB structure with ATOM/HETATM records.
- Must have the same number of atoms as each geometry in the XYZ file.
Output
The script generates one `.pdb` file per geometry in the input `.xyz`. Each output file contains:
- The atomic coordinates from the corresponding XYZ geometry.
- The atom ordering and other metadata from the base PDB file.
Output files are named using the specified prefix followed by an index (e.g.,
`output_prefix_1.pdb`, `output_prefix_2.pdb`, etc.).
Error Handling
- The script checks for mismatches between atom counts in the XYZ and PDB files and skips
invalid frames with a warning.
- If input files are missing or invalid, it exits with an error message.
Applications
This tool is ideal for:
1. Conver&ng large sets of molecular geometries from quantum chemistry scans into a
consistent PDB format.
2. Preparing input files for reparameteriza&on workflows in molecular dynamics simula&ons
(e.g., AMBER).
3. Ensuring consistency in atom ordering and nomenclature across mul&ple molecular
structures.
















**esp_charges_finder.py** script is designed to search for Electrostatic Potential (ESP) charges in .log files from a computational chemistry software (likely Gaussian) and calculate statistics (mean and standard deviation) for each atom's ESP charge across multiple files. Here's a summary of what the script does:
Script Description:
1.	Searches for ESP charges in .log files:
The script looks for the phrase "ESP charges:" in each .log file and extracts the following 73 lines (which correspond to the ESP charges of atoms). For each log file, it extracts the charges for the atoms and stores them in a dictionary.
2.	Explores directories recursively:
The script allows for recursive exploration of directories up to a user-defined depth, starting from the current working directory. The depth is determined by the user's input and can be set to 0 for the current directory or higher to include subdirectories.
3.	Calculates mean and standard deviation:
Once all ESP charges are extracted, the script calculates the mean and standard deviation for each atom's charge across the files it has processed. It excludes 0.0 values from the calculations.
4.	Generates a CSV report:
The results (ESP charges, mean, and standard deviation) are written to a CSV file called ESP_Charges.csv. The file contains:
o	The atom number.
o	The ESP charges for each file.
o	The mean and standard deviation for each atom across all files processed.
Key Features:
•	Customizable depth exploration: The user can specify how deep the script should explore subdirectories.
•	Handling missing data: If no data is available for a particular atom in a .log file, it is handled with a default value (0.0).
•	Statistical analysis: The script computes the mean and standard deviation of ESP charges across multiple files for each atom.









**frequencies_analyzer.py** script is designed to process multiple .log files, extract vibrational frequencies, and detect if any of them are negative (which might indicate an unstable structure). Here's a summary of its functionality:

Script Description:
Iterates through .log files:
The script recursively searches the current directory (and its subdirectories) for .log files using glob. For each .log file, it processes the content to extract vibrational frequencies.

Pattern Matching:
The script uses specific patterns to locate and extract vibrational frequencies:

The pattern search begins after finding the phrase "Low frequencies" in the file. It searches for a sequence of expected lines to locate and extract the frequencies:
"Diagonal vibrational"
"Harmonic"
"Frequencies --"
Extracts Frequencies and Checks for Negatives:
After identifying the line with the frequencies, the script:

Extracts the vibrational frequencies following the "Frequencies --" phrase.
Checks if the first frequency is negative (which might indicate an unstable mode) and marks it as "YES" if negative or "NO" if positive.
Writes Results to CSV:
The script outputs the results to a CSV file, "frequency_results.csv", with the following columns:

Filename: The name of the processed .log file.
Frequencies: The extracted vibrational frequencies.
Negatives?: Whether the first frequency is negative ("YES" or "NO").
Summary Output:

It prints out the names of the files processed along with the extracted frequencies and whether any negative frequencies were found.
Key Features:
Recursively processes files: The script searches for .log files in the current directory and subdirectories, making it suitable for large projects with multiple log files.
Pattern-based extraction: It looks for specific patterns to reliably extract vibrational frequencies.
CSV output: The results are saved in a CSV file for easy analysis and further processing.
Example Output (CSV):
The generated CSV file will contain rows like:

Filename, Frequencies, Negatives?
file1.log, 100.25 200.50 300.75, NO
file2.log, -50.25 150.10 200.80, YES

This script is useful for analyzing vibrational frequencies in computational chemistry studies, specifically for checking the stability of molecular structures based on frequency analysis.


